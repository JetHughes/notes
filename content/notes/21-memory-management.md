---
title: "21-memory-management"
aliases: 
tags: 
- cosc204
- lecture
sr-due: 2024-07-28
sr-interval: 363
sr-ease: 250
---

# storage heirachy
![slide|400](https://i.imgur.com/yls3Bun.png)
primary storage - cache and main memory
secondaryy - hard drive

as we move from secondary to primary:
- access speed increases
- access time decreases
- cost increases
- capacity decreases

# process memory image and logical and physical addresses
 - a program is compiled and linked into a process image before loading into memory for execution 
 - a process memory image consists of code section, data sections, lib sections, and stack sections 
 - each process has its own logical memory space starting from 0 and ending at a maximum address 
 - the logical address has to be translated into physical address before sending the memory request to the physical memory modules 
 - the memory management unit (MMU) translated between the logical addresse and the physical addresses. 
 
 - physical mode - progam refers directly to physical address
 - protected mode - dont allow program to use physical address directly - uses logical address
 - OS kernel creates a map from logical address to the physical address using a mapping table
 - CPUrefers to this table to map between physical and logical address

![address binding for process space slide|400](https://i.imgur.com/N0iAw0z.png)

# paging for memory translation

Noncontiguous paging: a processes logica address pace is broken int fixed size units called pages, and main memory is broken into units of the same size, called frames.

in a paged memory allocation scheme, the logical sddresses generated by the CPU are broken by special ardware itno two components: 
- page number
- offset (address within page)

![diagram|400](https://i.imgur.com/i3dn9IP.png)

page table indicates for each page which frame it's stored in.

- paging allows a process to be stored noncontigously in memory. 
-it is a way of implementing run-time address binding

![Example](https://i.imgur.com/L0TDBF0.png)

## memoy protection valid/invalid bits
each process takes up n pages. but the table typically has more than n entries.
So the page table stores a valid/invalid bit which is set to invalid for out-of-range memory refs

![diagam|400](https://i.imgur.com/gXLCCwg.png)

vald bits can also be changed to read only, read-write etc

![paging example](https://i.imgur.com/59hFyHd.png)

## fast memory (cache) for paging
fastest is to store page table in special registers
- not feasible if page table is large (which is usually is)
- alternative is to store page table in main memory
	- can slow things down
	- because to access an address in memory, we now need two or more memory accesses
- solution is to keep a cach eof table table entries that have been used recently, in a special set of paallel-access registers calles associateive registers
	- aka Translation look-aside buffer (TLB) 